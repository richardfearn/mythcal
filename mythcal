#! /usr/bin/python -W ignore

# mythcal

# Copyright 2009-2012 Richard Fearn
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

CONFIG_FILE = "mythcal.conf"
CACHE_FILE = "mythcal.cache"

VERSION = "0.25.1"

DATE_FORMAT = "%Y-%m-%d"
DATE_TIME_FORMAT = "%Y-%m-%dT%H:%M:%S.000Z"

import ConfigParser
from optparse import Values, OptionParser

from datetime import datetime
import pickle
import os
import sys

from MythTV import MythBE
import pytz
import gdata.calendar.service
import atom
import time

config = ConfigParser.RawConfigParser()
config.read(CONFIG_FILE)

settings = Values({
        "mythtv": Values({
                "timezone": config.get("mythtv", "timezone")
        }),
        "google": Values({
                "username": config.get("google", "username"),
                "password": config.get("google", "password")
        }),
        "calendar": Values({
                "name": config.get("calendar", "name"),
                "id": config.get("calendar", "id"),
                "max_batch_size" : int(config.get("calendar", "max_batch_size"))
        })
})

parser = OptionParser()
parser.add_option("-n", "--dry-run", action="store_true", dest="dry_run", default=False, help="perform a trial run; don't make any changes (implies -v)")
parser.add_option("-V", "--version", action="store_true", dest="version", default=False, help="show version and exit")
parser.add_option("-v", "--verbose", action="store_true", dest="verbose", default=False, help="increase verbosity")
(options, args) = parser.parse_args()

if options.version:
    print "mythcal %s" % VERSION
    sys.exit(0)

if options.dry_run:
    options.verbose = True

# get pytz timezone object for local time zone
if settings.mythtv.timezone not in pytz.all_timezones:
    print >>sys.stderr, "mythcal: timezone name '%s' is not recognised" % settings.mythtv.timezone
    sys.exit(1)
time_zone = pytz.timezone(settings.mythtv.timezone)

def mythtv_time_to_naive_utc_time(mythtv_time):
    """Convert MythTV time to naive UTC time"""
    naive_local_time = datetime.fromtimestamp(mythtv_time.timestamp())
    aware_local_time = time_zone.localize(naive_local_time)
    aware_utc_time = aware_local_time.astimezone(pytz.utc)
    naive_utc_time = aware_utc_time.replace(tzinfo=None)
    return naive_utc_time

def convert_program(prog):
    """Converts a MythTV Program object to a dictionary"""
    return {
        "title": prog.title,
        "subtitle": prog.subtitle,
        "channel": prog.channame,
        "start": mythtv_time_to_naive_utc_time(prog.starttime),
        "end": mythtv_time_to_naive_utc_time(prog.endtime),
        "description": prog.description
    }

def sort_programs_by_start(p1, p2):
    return cmp(p1["start"], p2["start"])

def get_recordings_from_backend():
    """Gets current and upcoming recordings from MythTV"""

    if options.verbose:
        print "Getting recordings from MythTV backend..."

    mythtv = MythBE()

    upcoming = mythtv.getUpcomingRecordings()
    upcoming = list(upcoming) # convert listiterator to list

    if options.verbose:
        print "    found %d upcoming recording(s)" % len(upcoming)

    upcoming = map(convert_program, upcoming)
    upcoming.sort(sort_programs_by_start)

    current = []
    for recorder in mythtv.getRecorderList():
        # str(...) required due to MythTV issue #7648
        # see http://svn.mythtv.org/trac/ticket/7648
        if mythtv.isRecording(str(recorder)):
            current.append(mythtv.getCurrentRecording(str(recorder)))
    if options.verbose:
        print "    found %d current recording(s)" % len(current)

    current = map(convert_program, current)
    current.sort(sort_programs_by_start)

    return {"current": current, "future": upcoming}

# get recordings from MythTV backend
recordings = get_recordings_from_backend()

# load recording list from last time
last_recordings = None
if os.path.exists(CACHE_FILE):
    if options.verbose:
        print "Reading cache file..."
    f = open(CACHE_FILE, "r")
    last_recordings = pickle.load(f)
    f.close()
    if options.verbose:
        print "Done."
else:
    if options.verbose:
        print "Cache file does not exist."

def submit_batch_request(request, url):
    response_feed = calendar_service.ExecuteBatch(request, url)
    # for entry in response_feed.entry:
    #     print "%s; status %s; reason %s" % (entry.batch_id.text, entry.batch_status.code, entry.batch_status.reason)

def delete_existing_events():
    """Deletes all events from the calendar"""

    if options.verbose:
        print "Deleting existing entries..."
    event_feed = calendar_service.GetCalendarEventFeed(cal.content.src)
    while event_feed and len(event_feed.entry):
        if not options.dry_run:
            batch_request = gdata.calendar.CalendarEventFeed()
        for event in event_feed.entry:
            if options.verbose:
                print "    will delete \"%s\"" % event.title.text
            if not options.dry_run:
                event.batch_id = gdata.BatchId(text="delete-request")
                batch_request.AddDelete(entry=event)
        if options.dry_run:
            if event_feed.GetNextLink():
                event_feed = calendar_service.GetCalendarEventFeed(event_feed.GetNextLink().href)
            else:
                event_feed = None
        else:
            if options.verbose:
                print "    (sending delete request)"
            submit_batch_request(batch_request, batch_url)
            event_feed = calendar_service.GetCalendarEventFeed(cal.content.src)
    if options.verbose:
        print "Existing entries deleted."

# update calendar, and output new recording list, if different
if recordings != last_recordings:

    # get calendar service and log in
    if options.verbose:
        print "Logging into Google Calendar..."
    calendar_service = gdata.calendar.service.CalendarService()
    calendar_service.email = settings.google.username
    calendar_service.password = settings.google.password
    calendar_service.source = "mythcal"
    calendar_service.ProgrammaticLogin()
    if options.verbose:
        print "Done."

    # Get all calendars
    if options.verbose:
        print "Getting all calendars..."
    calendars_feed = calendar_service.GetOwnCalendarsFeed()
    calendars = list(calendars_feed.entry)
    if options.verbose:
        print "Done."

    # if a calendar isn't available, limited information is returned, and the title isn't provided
    # Warn about calendars for which we don't get complete information
    calendars_without_titles = [c for c in calendars if not c.title]
    if calendars_without_titles:
        print >>sys.stderr, "mythcal: calendar list is incomplete; your calendar may not be found"

    # Try to find the specified calendar
    calendars = [c for c in calendars if c.title]
    calendars_by_name = dict((c.title.text, c) for c in calendars)
    if settings.calendar.name not in calendars_by_name:
        print >>sys.stderr, "mythcal: calendar '%s' not found" % settings.calendar.name
        sys.exit(1)
    else:
        cal = calendars_by_name[settings.calendar.name]

    # Build batch URL using the user-specified calendar ID
    batch_url = "http://www.google.com/calendar/feeds/%s/private/full/batch" % settings.calendar.id

    delete_existing_events()

    def create_event(title, start, end, content=None):
        event = gdata.calendar.CalendarEventEntry()
        event.title = atom.Title(text=title)
        if content:
            event.content = atom.Content(text=content)
        event.when.append(gdata.calendar.When(start_time=start, end_time=end))
        return event

    def create_all_day_event(title, start, end, content=None):
        event_start = time.strftime(DATE_FORMAT, start)
        event_end = time.strftime(DATE_FORMAT, end)
        return create_event(title=title, start=event_start, end=event_end, content=content)

    def create_programme_event(title, subtitle, channel, start, end, content=None):
        if subtitle:
            event_title = "%s: %s (%s)" % (title, subtitle, channel)
        else:
            event_title = "%s (%s)" % (title, channel)
        event_start = time.strftime(DATE_TIME_FORMAT, start)
        event_end = time.strftime(DATE_TIME_FORMAT, end)
        return create_event(title=event_title, start=event_start, end=event_end, content=content)

    if options.verbose:
        print "Adding new entries..."

    # add an event for current/future recordings
    if not options.dry_run:
        request_feed = gdata.calendar.CalendarEventFeed()
    for prog in recordings["current"] + recordings["future"]:
        if options.verbose:
            print "    will add \"%s\"" % prog["title"]
        if not options.dry_run:
            event = create_programme_event(prog["title"], prog["subtitle"], prog["channel"], prog["start"].timetuple(), prog["end"].timetuple(), prog["description"])
            event.batch_id = gdata.BatchId(text="insert-request")
            request_feed.AddInsert(entry=event)
            if len(request_feed.entry) == settings.calendar.max_batch_size:
                if options.verbose:
                    print "    (sending add request)"
                submit_batch_request(request_feed, batch_url)
                request_feed = gdata.calendar.CalendarEventFeed()

    # add 'last updated' event
    last_update_text = "MythTV updated %s" % time.strftime("%H:%M", time.localtime())
    if options.verbose:
        print "    will add \"%s\"" % last_update_text
    if not options.dry_run:
        event = create_all_day_event(title=last_update_text, start=time.gmtime(), end=time.gmtime(time.time() + 24*60*60))
        if options.verbose:
            print "    (sending add request)"
        event.batch_id = gdata.BatchId(text="insert-request")
        request_feed.AddInsert(entry=event)
        submit_batch_request(request_feed, batch_url)

    if options.verbose:
        print "New entries added."

    # update last recording list
    if options.verbose:
        print "Updating cache..."
    if not options.dry_run:
        f = open(CACHE_FILE, "w")
        pickle.dump(recordings, f)
        f.close()

    if options.verbose:
        print "Done."

else:
    if options.verbose:
        print "Recordings have not changed; not updating calendar."

if options.verbose:
    print "Finished."
